---
layout: post
title:  Организация работы в Mercurial
date:   2020-12-03
image:  '/assets/img/37a2fbd322d4f34657010159320e2557.png'
tags:   Mercurial
---

## Введение

Mercurial - распределенная кроссплатформенная система управления версиями, разработана для эффективной работы с репозиториями кода, можно использовать для работы с документами.

Основная цель статья это не рассказать про команды, а про то, как эффективно работать в команде с этим полезным инструментом. В силу того, что я довольно часто встречал ситуации, когда люди не умеют пользоваться системами контроля версий, делают странные коммиты, не понимает зачем нужны ветки и почему коммить код надо не раз в месяц. Хотелось бы раскрыть глаза новичкам или даже опытным сеньорам.
## Установка

Для начала необходимо установить [Mercurial](https://www.mercurial-scm.org). Делается это довольно просто, скачать программу, далее по шагам установить.
Советую использовать десктопный графический клиент [TortoiseHg](https://ru.wikipedia.org/wiki/TortoiseHg).

После установки проверить, что всё прошло успешно, у меня это выглядит так:
```
$ hg version

$ Распределенная SCM Mercurial (версия 5.2)
(see https://mercurial-scm.org for more information)

Copyright (C) 2005-2019 Matt Mackall and others
This is free software; see the source for copying conditions. There is NO
warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
```

Видно, что установка прошла успешно и установлена версия 5.2.

## Работа в TortoiseHg

Запускаем программу TortoiseHg.

Для начала необходимо склонировать себе репозиторий на свой компьютер, делается это просто. В меню выбираем File -> Clone repository:
![](/assets/img/clone_repository.jpg)
В Source необходимо указать ссылку на репозиторий. Я ставлю ещё галочку (Do not verify host certificate), это специфика моей компании, мне не надо проверять SSL сертификат. Для любознательных, в Hg command можно изучить какой командой вытягивается репозиторий. Далее, необходимо будет ввести логин и пароль.

Подождать, пока какое-то время будет происходить копирование:
![](/assets/img/clone_repository_in_progress.jpg)

После копирования, вы увидите примерно следующее:
![](/assets/img/done_clone.jpg)

Наверное страшно, что это всё такое?

Разберёмся.

Branch - это ветки, используются почти каждый день, между ними приходится часто прыгать, это наборы разных изменений в проекте. Graph - визуально показывает разными цветами все ветки и пересечения между ними. Description - это сообщение коммита, которое пишет разработчик, фиксируя какое-то либо изменение. Tags - идентификатор набора изменений, иногда удобно помечать некоторые изменения тегами. Rev - номер коммита.

Когда мы склонировали репозиторий, то находимся на дефолтной ветке в проекте, обычно это ветка default, зависит от настроек репозитория. Чтобы узнать на какой ветке находимся. Идём в меню Repository -> Update. В Parent написана текущая ветка, выше список, который позволяет выбрать ветку, которая уже есть и нажатием кнопки update переключиться на последний коммит в выбранной ветке.

Например, я хочу переключиться на ветку dev:
![](/assets/img/to_dev.jpg)

Обычно, в компании всегда есть девелоперская ветка (dev), в которой хранятся все изменения в проекте. Также есть ветка мастер (master), в неё обычно [сливается](https://hgbook.bacher09.org/html/a-tour-of-mercurial-merging-work.html) код, который уже оттестирован и точно работает.
Также, довольно часто есть ветки так называемых фичей, в которые размещаются изменения того или иного функционала, добавляемых в проект. Например, ветка feature/name_feature, всегда перед названием фичи рекомендутся добавлять feature, чтобы было понятно, что это ветка новой фичи.
Ещё есть ветки багфиксов, это когда исправляется какая-та ошибка и делается это обычно в отдельной ветке, рекомендуемые названия bugfix/name_change.
Дальше, когда фича или багфикс полностью реализован и протестирован, дальше нужно сливать в dev ветку, где проводится регресионное тестирование всей системы, чтоб убедиться, что ваше чудесное изменение не сломало весь проект.

И, когда мы уверены, что всё хорошо, команда решила или кто-то сверху, добавляют такую-то фичу в новую версию продукта и/или исправления каких-то багов, то в тот момент времени сливается ветка dev в ветку master, вся команда молится во в главе с отделом [QA](https://ru.wikipedia.org/wiki/Обеспечение_качества), что ничего не сломалось, ибо в master лежит продакшн код.
### Коммиты
Допустим, мы добавили нужный функционал, как же правильно его разместить в удалённый репозиторий?

Для начало нужно выбрать файлы, которые мы добавили, отредактировали или удалили, выбрать нужные галочками. Файлы помечаются разными типами, обычно используются три:
- M - модификация файла;
- А - добавление нового файла;
- R - удаление файла.

Ещё есть файлы игнора, которые не надо отправлять в репозиторий, чтобы его на засорять, например, это какие-то настройки среды разработки. В репозиторий, отправляются только **исходники*.

Далее, нам нужно создать новую ветку, раз мы добавили фичу. Жмём на название самой фичи:
![](/assets/img/click_branch.jpg)
Вводим новое название и нажимаем ОК:
<div style="text-align:center"><img src="/assets/img/new-branch.jpg" width="80%" text-align="center"/></div>
<br>
Теперь необходимо написать сообщение в коммиту, сообщения принято писать на английском языке, чтоб было любому понятно что это такое и также не было проблем с кодировкой. Сообщение необходимо писать кратко и в тоже время это не целая поэма, вообщем лаконично.
Надо понимать, что ваше сообщение потом будет читать другой разработчик и сложно разобраться когда подряд делается несколько коммитов с одинаковым сообщением. Вообще, чтение чужого кода и коммитов занимает довольную большую часть времени.

Супер, дальше нажимаем Commit, вылезит окошко, жмём Create Branch:
![](/assets/img/new-commit.jpg)
Отлично, мы зафиксировали изменение кода локально, теперь нужно отправить изменения в удалённый репозиторий, для это надо нажать кнопку push, найти её можно в меню Repository -> Synchronize -> Push.
Далее, подтвердите что хотите запушить. Также, меркуриал вас спросит, уверены ли вы, что хотите создать в удалённом репозитории ветку, жмите да.
Должно получится, что-то вроде такого:
![](/assets/img/push.jpg)
Некоторые рекомендации по коммитам, не нужно лепить пачку изменений сразу в один коммит, создавайте на каждое изменение отдельный коммит. Во-первых, жирный коммит не очень читабельный и сложно описать сообщением.
Во-вторых, бывает часто нужно вернуться на старую версию, когда все сломалось, а такое бывает не очень редко, Team Lead/Senior/да и в принципе любой разработчик будет в гневе, если вы лепите всё в один коммит.
И, чтобы пол года не разбираться на чём именно у нас тут все легло, откатывают весь ваш коммит, а допустим он включает сразу 3 фичи, но сломалась одна фича. Логично, что это не очень удобно.
А 2 другие фичи могли принести деньги компании, которые не включились в сборку вот именно сейчас.
<div style="text-align:center"><img src="/assets/img/mem_commit.jpg" /></div>
<br>
Другая сторона, нужно коммить хотя бы раз в три дня или в неделю, за этот срок возможно сделать что-то по задачам, если вы работаете спринтами, а хранить код на своей машине не очень безопасно, у меня были случаи когда машина ломалась.
Если вы завершили работу на какой-то задачей, сделайте коммит, не надо стесняться, плохой подход, когда вы делаете это раз в месяц и тогда встаёт вопрос, что вы делали целый месяц? Пили кофе?

Допустим, всё прошло успешно, ваша фича проверена, необходимо её слить в ветку dev.

Для этого нужно обновиться до ветки dev, в которую мы хотим слить нашу фичу. Далее, жмем правой кнопкой мыши на коммит, который нам нужно слить в dev и выбираем Merge with Local:
<div style="text-align:center"><img src="/assets/img/merge_with_local.jpg" width="80%" text-align="center"/></div>
<br>
Если вы в себе уверены, поставьте вторую галочку, это позволит автоматически разрешить все изменения между ветками (если вы начинающий разработчик, то советую обратиться в старшему разработчику и сделать это под его присмотром):
![](/assets/img/merge.jpg)
Я поставил галочку на предыдущем шаге и нажал далее, далее можно поставить галочку, чтобы сразу сделать коммит, у меня все прошло успешно, конфликтов нет, но такое в реальных проектах редкость, особенно если большая команда разработчиков:
![](/assets/img/merge_done.jpg)
Сообщение обычно ставится автоматом такого плана Merge with name_branch, жмем Commit Now:
![](/assets/img/merge_and_commit_now.jpg)
Поздравляю, мы замёржили (выше я писал сливаем, чтобы вас сразу не пугать, теперь вы знаете что это значит merge) две ветки, это успех, жмём Done:
![](/assets/img/merge_done_full.jpg)
Теперь, по той же схеме, что ранее, нужно сделать push, чтобы это все отразилось на удалённом репозитории.
Идём в меню Repository -> Synchronize -> Push. Наблюдаем, что наше ответление в графе вернулось в dev:
![](/assets/img/graph.jpg)
По такой же схеме мёржатся любые ветки.
### Откатить
Что делать если вдруг ваш коммит всё сломал или вы вообще по ошибке сделали пуш?

Выход есть, для этого есть удобная команда backout, она позволяет автоматически отменить всю ревизию и создать новую ревизию, которая отражает состояние репозитория без уже ошибочной ревизии.

Жмём правой кнопки мыши на коммит, который мы хотим убрать и выбираем Backout:
<div style="text-align:center"><img src="/assets/img/backout_click.jpg" width="80%" text-align="center"/></div>
<br>
Далее, открывается окошко где написано что убираем и какая у нас сейчас локальная ревизия, жмём далее (как обычно ставим галочку, у нас тут всё просто и автоматом разрешится):
![](/assets/img/backout_progress.jpg)
Делаем коммит:
![](/assets/img/backout_commit.jpg)
Видим, что все успешно, нажимаем Done:
![](/assets/img/backout_done.jpg)
Не забываем, что надо ещё сделать пуш. В меню Repository -> Synchronize -> Push. Иначе изменения не отразятся в удалённом репозитории.

### Закрыть ветку

Бывают ситуации, когда кто-то ошибочно создал кучу веток или создал несколько головок одной ветки.
Головка это по сути несколько веток с одним названием, да, это не git, здесь так можно сделать и надо очень внимательно все делать. Это происходит часто, когда человек делает пуш, но перед этим не смотрит есть ли в удалённом репозитории какие-то изменения, то есть не делает pull.
Узнать сколько головок имеет одна ветка можно командой:
```
$hg heads name_branch
```
Для закрытия ветки есть варианты, например, merge и это считается лучшим вариантом.
Но, когда мы понимаем, что ветка точно не нужна и нам надо её убить. Находимся в нужной ветке, которую нам надо закрыть, жмём на её название и выбираем пункт Close current branch:
<div style="text-align:center"><img src="/assets/img/close_branch.jpg" width="80%" text-align="center"/></div>
<br>
Дальше коммит и как обычно пуш.
![](/assets/img/close_branch_commit.jpg)

На этом всё, этих знаний должно хватить на первое время, если будут сложности, то смотрите эту [документацию](https://hgbook.bacher09.org/html/how-did-we-get-here.html).

---